#include <windows.h>
#include <stdio.h>

#define okay(msg, ...) printf("[+] " msg "\n", ##__VA_ARGS__)
#define warn(msg, ...) printf("[-] " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) printf("[i] " msg "\n", ##__VA_ARGS__)

int main(int argc, char* argv[]) {

    DWORD dwPID = NULL, dwTID = NULL;
    HANDLE hProcess = NULL, hThread = NULL;
    HMODULE hKernel32 = NULL;
    LPVOID rBuffer = NULL;
    char dllPath[MAX_PATH] = "dynamicLinkLibrary.dll";
    size_t dllPathSize = sizeof(dllPath);
    size_t bytesWritten = NULL;

    if (argc < 2) {
        warn("Usage: %s <PID>", argv[0]);
        return EXIT_FAILURE;
    }

    dwPID = atoi(argv[1]);

    info("Trying to get a handle to the process (%ld)", dwPID);

    hProcess = OpenProcess((PROCESS_VM_OPERATION | PROCESS_VM_WRITE), FALSE, dwPID);

    if (hProcess == NULL) {
        warn("Failed to get a handle to the process (%ld), Error: 0x%lx", dwPID, GetLastError());
        return EXIT_FAILURE;
    }

    okay("Got a handle to the process (%ld)!", dwPID);
    info("\\___[ hProcess\n\t\\_0x%p]\n", hProcess);

    info("Trying to get a handle to Kernel32.dll");

    hKernel32 = GetModuleHandle("kernel32");

    if (hKernel32 == NULL) {
        warn("Failed to get a handle to Kernel32.dll, Error: 0x%lx", GetLastError());
        return EXIT_FAILURE;
    }

    okay("Got a handle to Kernel32.dll!");
    info("\\___[ hKernel32\n\t\\_0x%p]\n", hKernel32);

    info("Trying to get the address of LoadLibraryW()");

    LPTHREAD_START_ROUTINE lptsrLoadLibrary = (LPTHREAD_START_ROUTINE) GetProcAddress(hKernel32, "LoadLibraryW");
    
    if (lptsrLoadLibrary == NULL) {
        warn("Failed to get the address of LoadLibraryW(), Error: 0x%lx", GetLastError());
        return EXIT_FAILURE;
    }

    okay("Got the address of LoadLibraryW()");
    info("\\___[ LoadLibraryW\n\t\\_0x%p]\n", lptsrLoadLibrary);

    info("Trying to allocate memory to the target process (%ld)", dwPID);
    
    rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

    if (rBuffer == NULL) {
        warn("Failed to allocate memory to the target process (%ld), Error: 0x%lx", dwPID, GetLastError());
        return EXIT_FAILURE;
    }

    okay("Allocated a buffer of %zd-bytes to the target process memory w/ PAGE_READWRITE permissions", dllPathSize);

    info("Trying to write the DLL to the allocated buffer");

    if (!WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, &bytesWritten)) {
        warn("Failed to write the DLL to the allocated buffer, Error: 0x%lx", GetLastError());
        return EXIT_FAILURE;
    }

    okay("Wrote the DLL of %zd-bytes to the allocated buffer", bytesWritten);

    info("Trying to create a thread and get a handle to it");

    hThread = CreateRemoteThread(hProcess, NULL, 0, lptsrLoadLibrary, rBuffer, 0, &dwTID);

    if (hThread == NULL) {
        warn("Failed to create a thread and get a handle to it, Error: 0x%lx", GetLastError());
        return EXIT_FAILURE;
    }

    okay("Created a thread and got a handle to it (%ld)", dwTID);
    info("\\___[ hThread\n\t\\_0x%p]\n", hThread);

    info("Waiting for the thread to finish executing");

    WaitForSingleObject(hThread, INFINITE);

    okay("Thread finished executing, Cleaning up");

    goto CLEANUP;

CLEANUP:

    if (hProcess) {
        info("Closing handle to the process");
        CloseHandle(hProcess);
    }

    if (hThread) {
        info("Closing handle to the thread");
        CloseHandle(hThread);
    }

    okay("Finished!");

    return EXIT_SUCCESS;
}